#summary finding news entries for the same topic

== What do we wanna do in this example? ==

We want to find news from different RSS feeds that are about the same topic (like google news does it)

== How can we achieve this? ==

We fetch the RSS feeds, and have the webpages containing the actual news tagged by [http://tagthe.net tagthe.net], which gives us information about topics, persons and locations contained in that news. Later on, we compare the tags for each newssite and we will assume that if more than 25% of the tags are the same, the news are about the same topic.

== Step by Step ==

At first we write a step that fetches some rss feeds and find the news URIs in them. Each of these URIs will be given to another step that will tag them.

{{{
createStep({
	getUrl: function() {
		if ( typeof(this.params.feedUrl) == "undefined" )
			return "http://www.tagesschau.de/newsticker.rdf";
			
		return this.params.feedUrl;
	},
	run: function() {		
			
		//parse another feed
		if ( typeof(this.params.feedUrl) == "undefined") {
			addStep("tagRss/feed", { feedUrl: "http://www.spiegel.de/schlagzeilen/rss/0,5291,20,00.xml" } );
			addStep("tagRss/feed", { feedUrl: "http://www.n-tv.de/23.rss" } );	
			addStep("tagRss/feed", { feedUrl: "http://www.faz.net/s/Rub/Tpl~Epartner~SRss_.xml" } );
			addStep("tagRss/feed", { feedUrl: "http://www.jungewelt.de/aktuell/newsticker.rss" } );
			addStep("tagRss/feed", { feedUrl: "http://www.n24.de/2/nachrichten/index.rss" } );
		}	
			
		for each( var link in this.xmlObj..item..link ) {
			addStep("tagRss/tagIt", { url: String(link) } );
		}
	}	
});
}}}

The next step makes a request to tagthe.net, parses the XML answer for topic, location and persons tags and saves them as XML in the Execution Context for further processing.

{{{
createStep({
	getUrl: function() {
		return "http://tagthe.net/api/?url="+this.params.url;
	},
	run: function() {		
		
		var result= <result url={this.params.url} />;
		
		for each( var dim in this.xmlObj..dim ) {
				
			var type = String( dim.@type );
			
			if ( type == "location" || type == "person" || type == "topic" ) {
			
				var tags = <tags type={type}/>;
				
				for each( var item in dim..item )
					tags.appendChild( <tag>{String(item)}</tag> ); 
					
				result.appendChild( tags );	
			}
		}
		
		print( "tagged "+this.params.url+"..." );
		
		this.addToMemory( this.params.url, result.toXMLString() ); 		
	}
});
}}}


|| *NOTE*:  The following code is just a proof of concept that we really find results (it eats lot of memory...). Statistical analysis should not be done in Javascript (particularly not in Javascript interpreted by Java) but with the use of a database or XML processing utilities, it is not the intention of dine to be usable for this ||

This is not a step, its a result processor, which is Javascript code that is automatically executed when all steps are finished. It loads the found tags from the Execution Context and compares them. It's messy and kinda unreadable but it's just a proof that we really find some results..

{{{
createExecutable({

	run: function() {		
		
		var keys = this.memoryKeys();
		var taggedResults = {};
		
		for ( n=0; n<keys.length; n++ )		
			taggedResults[ keys[n] ] = new XML( this.fromMemory( keys[n] ) ); 

		var urlC = 0;

		for ( var url in taggedResults ) {
		
			var otherUrlC = 0; 
				
			for ( var otherUrl in taggedResults ) {
									
				if ( urlC < otherUrlC && extractDomainName( url ) != extractDomainName( otherUrl) ) {
		
					var rate = 0;
					
					rate += compareXML( taggedResults, url, otherUrl, "topic" );
					rate += compareXML( taggedResults, url, otherUrl, "location" );
					rate += compareXML( taggedResults, url, otherUrl, "person" );

					rate = Math.ceil( ((rate/3)*100) );	
					
					if ( rate > 25 )
						print("MATCH ("+rate+"%): "+url+" | "+otherUrl );								
				}
				
				otherUrlC++;
			}
			
			urlC++;
		}

	}
});

function extractDomainName( url ) {

	domain = url.match( /:\/\/(www\.)?([^\/:]+)/ );

	return domain[2] ? domain[2] : '';
}

function compareXML( taggedResults, url, otherUrl, tagType ) {

					var urlTagNum 		= 0;
					var otherUrlTagNum 	= 0;	
					var matchingTagNum 	= 0;

					for each( var tag in taggedResults[url].tags.(@type=tagType).tag ) {
					
						urlTagNum++;
					
						for each( var otherTag in taggedResults[otherUrl].tags.(@type=tagType).tag ) {						
							
							otherUrlTagNum++;

							if ( String(tag) == String(otherTag) )
								matchingTagNum++;
						}
					}		

					if ( urlTagNum == 0 ) return 0;

					otherUrlTagNum = otherUrlTagNum/urlTagNum;
					
					var tagNum = Math.max( urlTagNum, otherUrlTagNum );

					return ( urlTagNum != 0 ) ? matchingTagNum/tagNum : 0;	 
}
}}}